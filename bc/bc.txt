








         BBCC −− AAnn AArrbbiittrraarryy PPrreecciissiioonn DDeesskk‐‐CCaallccuullaattoorr LLaanngguuaaggee


                            _L_o_r_i_n_d_a _C_h_e_r_r_y
                            _R_o_b_e_r_t _M_o_r_r_i_s


                               _A_B_S_T_R_A_C_T

           BC  is  a language and a compiler for doing arbitrary
      precision arithmetic on the PDP‐11 under the  UNIX®  time‐
      sharing system.  The output of the compiler is interpreted
      and executed by a collection of routines which can  input,
      output,  and  do arithmetic on indefinitely large integers
      and on scaled fixed‐point numbers.

           These routines are  themselves  based  on  a  dynamic
      storage  allocator.   Overflow  does  not  occur until all
      available core storage is exhausted.

           The language has a complete control structure as well
      as immediate‐mode operation.  Functions can be defined and
      saved for later execution.

           Two five hundred‐digit numbers can be  multiplied  to
      give a thousand digit result in about ten seconds.

           A  small  collection  of  library  functions  is also
      available, including sin, cos, arctan,  log,  exponential,
      and Bessel functions of integer order.

           Some of the uses of this compiler are

      −    to do computation with large integers,

      −    to do computation accurate to many decimal places,

      −    conversion of numbers from one base to another base.



IInnttrroodduuccttiioonn

     BC  is  a  language  and a compiler for doing arbitrary precision
arithmetic on the UNIX time‐sharing  system  [1].   The  compiler  was
written  to  make  conveniently  available  a  collection  of routines
(called DC [5]) which are capable of doing arithmetic on  integers  of
arbitrary  size.   The  compiler  is by no means intended to provide a
complete programming language.  It is a minimal language facility.











     USD:6‐2 BC − An Arbitrary Precision Desk‐Calculator Language


          There is a scaling provision that  permits  the  use  of  decimal
     point notation.  Provision is made for input and output in bases other
     than decimal.  Numbers can be converted from decimal to octal by  sim‐
     ply setting the output base to equal 8.

          The  actual limit on the number of digits that can be handled de‐
     pends on the amount of storage available on the machine.  Manipulation
     of numbers with many hundreds of digits is possible even on the small‐
     est versions of UNIX.

          The syntax of BC has been deliberately selected to agree substan‐
     tially  with  the  C language [2].  Those who are familiar with C will
     find few surprises in this language.

     SSiimmppllee CCoommppuuttaattiioonnss wwiitthh IInntteeggeerrss

          The simplest kind of statement is an arithmetic expression  on  a
     line by itself.  For instance, if you type in the line:

          114422885577 ++ 228855771144

     the program responds immediately with the line

          442288557711

     The  operators  −, *, /, %, and ^ can also be used; they indicate sub‐
     traction, multiplication, division, remaindering, and  exponentiation,
     respectively.   Division  of integers produces an integer result trun‐
     cated toward zero.  Division by zero produces an error comment.

          Any term in an expression may be prefixed by a minus sign to  in‐
     dicate that it is to be negated (the ‘unary’ minus sign).  The expres‐
     sion

          77++−−33

     is interpreted to mean that −3 is to be added to 7.

          More complex expressions with several operators and  with  paren‐
     theses  are interpreted just as in Fortran, with ^ having the greatest
     binding power, then * and % and /, and finally + and −.   Contents  of
     parentheses  are  evaluated  before  material outside the parentheses.
     Exponentiations are performed from right to left and the other  opera‐
     tors from left to right.  The two expressions

          aa^^bb^^cc  aanndd  aa^^((bb^^cc))

     are equivalent, as are the two expressions

          aa**bb**cc  aanndd  ((aa**bb))**cc

     BC shares with Fortran and C the undesirable convention that











     BC − An Arbitrary Precision Desk‐Calculator Language USD:6‐3


          aa//bb**cc  is equivalent to  ((aa//bb))**cc


          Internal storage registers to hold numbers have single lower‐case
     letter names.  The value of an expression can be assigned to a  regis‐
     ter in the usual way.  The statement

          xx == xx ++ 33

     has the effect of increasing by three the value of the contents of the
     register named x.  When, as in this case, the outermost operator is an
     =, the assignment is performed but the result is not printed.  Only 26
     of these named storage registers are available.

          There is a built‐in square root function whose  result  is  trun‐
     cated to an integer (but see scaling below).  The lines

          xx == ssqqrrtt((119911))
          xx

     produce the printed result

          1133


     BBaasseess

          There   are  special  internal  quantities,  called  ‘ibase’  and
     ‘obase’.  The contents of ‘ibase’, initially set to 10, determines the
     base used for interpreting numbers read in.  For example, the lines

          iibbaassee == 88
          1111

     will produce the output line

          99

     and  you  are  all set up to do octal to decimal conversions.  Beware,
     however of trying to change the input base back to decimal by typing

          iibbaassee == 1100

     Because the number 10 is interpreted as  octal,  this  statement  will
     have no effect.  For those who deal in hexadecimal notation, the char‐
     acters A−F are permitted in numbers (no matter what base is in effect)
     and  are  interpreted as digits having values 10−15 respectively.  The
     statement

          iibbaassee == AA

     will change you back to decimal input base no matter what the  current
     input  base is.  Negative and large positive input bases are permitted
     but useless.   No  mechanism  has  been  provided  for  the  input  of









     USD:6‐4 BC − An Arbitrary Precision Desk‐Calculator Language


     arbitrary numbers in bases less than 1 and greater than 16.

          The  contents  of  ‘obase’,  initially set to 10, are used as the
     base for output numbers.  The lines

          oobbaassee == 1166
          11000000

     will produce the output line

          33EE88

     which is to be interpreted as  a  3‐digit  hexadecimal  number.   Very
     large  output bases are permitted, and they are sometimes useful.  For
     example, large numbers can be output in groups of five digits by  set‐
     ting ‘obase’ to 100000.  Strange (i.e. 1, 0, or negative) output bases
     are handled appropriately.

          Very large numbers are split across lines with 70 characters  per
     line.   Lines  which are continued end with \.  Decimal output conver‐
     sion is practically instantaneous, but output of  very  large  numbers
     (i.e.,  more  than  100 digits) with other bases is rather slow.  Non‐
     decimal output conversion of a one hundred digit  number  takes  about
     three seconds.

          It  is  best  to remember that ‘ibase’ and ‘obase’ have no effect
     whatever on the course of internal computation or on the evaluation of
     expressions,  but  only  affect  input  and output conversion, respec‐
     tively.

     SSccaalliinngg

          A third special internal quantity called ‘scale’ is used  to  de‐
     termine  the scale of calculated quantities.  Numbers may have up to a
     specific number of decimal digits after the decimal point.  This frac‐
     tional part is retained in further computations.  We refer to the num‐
     ber of digits after the decimal point of a number as its  scale.   The
     current  implementation  allows scales to be as large as can be repre‐
     sented by a 32‐bit unsigned number minus one.  This is a  non‐portable
     extension.  The original implementation allowed for a maximum scale of
     99.

          When two scaled numbers are combined  by  means  of  one  of  the
     arithmetic  operations,  the result has a scale determined by the fol‐
     lowing rules.  For addition and subtraction, the scale of  the  result
     is  the larger of the scales of the two operands.  In this case, there
     is never any truncation of the result.  For multiplications, the scale
     of  the result is never less than the maximum of the two scales of the
     operands, never more than the sum of the scales of the  operands  and,
     subject  to  those  two  restrictions,  the scale of the result is set
     equal to the contents of the internal quantity ‘scale’.  The scale  of
     a  quotient  is  the  contents  of the internal quantity ‘scale’.  The
     scale of a remainder is the sum of the scales of the quotient and  the
     divisor.   The result of an exponentiation is scaled as if the implied









     BC − An Arbitrary Precision Desk‐Calculator Language USD:6‐5


     multiplications were performed.  An exponent must be an integer.   The
     scale of a square root is set to the maximum of the scale of the argu‐
     ment and the contents of ‘scale’.

          All of the internal operations are actually carried out in  terms
     of  integers,  with  digits  being discarded when necessary.  In every
     case where digits are discarded, truncation and not rounding  is  per‐
     formed.

          The contents of ‘scale’ must be no greater than 4294967294 and no
     less than 0.  It is initially set to 0.

          The internal quantities ‘scale’, ‘ibase’, and ‘obase’ can be used
     in expressions just like other variables.  The line

          ssccaallee == ssccaallee ++ 11

     increases the value of ‘scale’ by one, and the line

          ssccaallee

     causes the current value of ‘scale’ to be printed.

          The  value  of ‘scale’ retains its meaning as a number of decimal
     digits to be retained in internal computation  even  when  ‘ibase’  or
     ‘obase’  are  not  equal  to 10.  The internal computations (which are
     still conducted in decimal, regardless of the bases) are performed  to
     the  specified number of decimal digits, never hexadecimal or octal or
     any other kind of digits.

     FFuunnccttiioonnss

          The name of a function is a single lower‐case  letter.   Function
     names are permitted to collide with simple variable names.  Twenty‐six
     different defined functions are permitted in addition to  the  twenty‐
     six variable names.  The line

               ddeeffiinnee aa((xx)){{

     begins the definition of a function with one argument.  This line must
     be followed by one or more statements, which make up the body  of  the
     function, ending with a right brace }.  Return of control from a func‐
     tion occurs when a return statement is executed or when the end of the
     function  is reached.  The return statement can take either of the two
     forms

          rreettuurrnn
          rreettuurrnn((xx))

     In the first case, the value of the function is 0, and in the  second,
     the value of the expression in parentheses.

          Variables  used in the function can be declared as automatic by a
     statement of the form









     USD:6‐6 BC − An Arbitrary Precision Desk‐Calculator Language


          aauuttoo xx,,yy,,zz

     There can be only one ‘auto’ statement in a function and  it  must  be
     the  first statement in the definition.  These automatic variables are
     allocated space and initialized to zero on entry to the  function  and
     thrown  away  on  return.   The  values of any variables with the same
     names outside the function are not disturbed.  Functions may be called
     recursively and the automatic variables at each level of call are pro‐
     tected.  The parameters named in a function definition are treated  in
     the same way as the automatic variables of that function with the sin‐
     gle exception that they are given a value on entry  to  the  function.
     An example of a function definition is

               ddeeffiinnee aa((xx,,yy)){{
                    aauuttoo zz
                    zz == xx**yy
                    rreettuurrnn((zz))
               }}

     The  value  of  this function, when called, will be the product of its
     two arguments.

          A function is called by the appearance of its name followed by  a
     string  of  arguments enclosed in parentheses and separated by commas.
     The result is unpredictable if the wrong number of arguments is used.

          Functions with no arguments are defined and called  using  paren‐
     theses with nothing between them: b().

          If the function _a above has been defined, then the line

          aa((77,,33..1144))

     would cause the result 21.98 to be printed and the line

          xx == aa((aa((33,,44)),,55))

     would cause the value of x to become 60.

     SSuubbssccrriipptteedd VVaarriiaabblleess

          A  single  lower‐case letter variable name followed by an expres‐
     sion in brackets is called a subscripted variable (an array  element).
     The  variable  name  is  called  the  array name and the expression in
     brackets is called the subscript.   Only  one‐dimensional  arrays  are
     permitted.   The  names  of  arrays  are permitted to collide with the
     names of simple variables and function names.  Any fractional part  of
     a  subscript is discarded before use.  Subscripts must be greater than
     or equal to zero and less than or equal to 2047.

          Subscripted variables may be freely used in expressions, in func‐
     tion calls, and in return statements.











     BC − An Arbitrary Precision Desk‐Calculator Language USD:6‐7


          An array name may be used as an argument to a function, or may be
     declared as automatic in a function definition by  the  use  of  empty
     brackets:

          ff((aa[[]]))
          ddeeffiinnee ff((aa[[]]))
          aauuttoo aa[[]]

     When  an  array  name  is so used, the whole contents of the array are
     copied for the use of the function, and thrown away on exit  from  the
     function.   Array  names which refer to whole arrays cannot be used in
     any other contexts.

     CCoonnttrrooll SSttaatteemmeennttss

          The ‘if’, the ‘while’, and the ‘for’ statements may  be  used  to
     alter  the  flow  within programs or to cause iteration.  The range of
     each of them is a statement or a compound statement  consisting  of  a
     collection  of statements enclosed in braces.  They are written in the
     following way

          iiff((rreellaattiioonn)) ssttaatteemmeenntt
          iiff((rreellaattiioonn)) ssttaatteemmeenntt eellssee ssttaatteemmeenntt
          wwhhiillee((rreellaattiioonn)) ssttaatteemmeenntt
          ffoorr((eexxpprreessssiioonn11;; rreellaattiioonn;; eexxpprreessssiioonn22)) ssttaatteemmeenntt

     or

          iiff((rreellaattiioonn)) {{ssttaatteemmeennttss}}
          iiff((rreellaattiioonn)) {{ssttaatteemmeennttss}} eellssee {{ssttaatteemmeennttss}}
          wwhhiillee((rreellaattiioonn)) {{ssttaatteemmeennttss}}
          ffoorr((eexxpprreessssiioonn11;; rreellaattiioonn;; eexxpprreessssiioonn22)) {{ssttaatteemmeennttss}}


          A relation in one of the control statements is an  expression  of
     the form

          xx>>yy

     where  two expressions are related by one of the six relational opera‐
     tors ‘<’, ‘>’, ‘<=’, ‘>=’, ‘==’, or ‘!=’.  The  relation  ‘==’  stands
     for ‘equal to’ and ‘!=’ stands for ‘not equal to’.  The meaning of the
     remaining relational operators is clear.

          BEWARE of using ‘=’ instead of ‘==’ in  a  relational.   Unfortu‐
     nately,  both of them are legal, so you will not get a diagnostic mes‐
     sage, but ‘=’ really will not do a comparison.

          The ‘if’ statement causes execution of its range if and  only  if
     the  relation  is  true.  Then control passes to the next statement in
     sequence.  If an ‘else’ branch is  present,  the  statements  in  this
     branch are executed if the relation is false.  The ‘else’ keyword is a
     non‐portable extension.










     USD:6‐8 BC − An Arbitrary Precision Desk‐Calculator Language


          The ‘while’ statement causes execution of its range repeatedly as
     long as the relation is true.  The relation is tested before each exe‐
     cution of its range and if the relation is false,  control  passes  to
     the next statement beyond the range of the while.

          The  ‘for’ statement begins by executing ‘expression1’.  Then the
     relation is tested and, if true, the statements in the  range  of  the
     ‘for’  are executed.  Then ‘expression2’ is executed.  The relation is
     tested, and so on.  The typical use of the ‘for’ statement  is  for  a
     controlled iteration, as in the statement

          ffoorr((ii==11;; ii<<==1100;; ii==ii++11)) ii

     which will print the integers from 1 to 10.  Here are some examples of
     the use of the control statements.

          ddeeffiinnee ff((nn)){{
          aauuttoo ii,, xx
          xx==11
          ffoorr((ii==11;; ii<<==nn;; ii==ii++11)) xx==xx**ii
          rreettuurrnn((xx))
          }}

     The line

               ff((aa))

     will print _a factorial if _a is a positive integer.  Here is the  defi‐
     nition of a function which will compute values of the binomial coeffi‐
     cient (m and n are assumed to be positive integers).

          ddeeffiinnee bb((nn,,mm)){{
          aauuttoo xx,, jj
          xx==11
          ffoorr((jj==11;; jj<<==mm;; jj==jj++11)) xx==xx**((nn−−jj++11))//jj
          rreettuurrnn((xx))
          }}

     The following function computes values of the exponential function  by
     summing  the appropriate series without regard for possible truncation
     errors:






















     BC − An Arbitrary Precision Desk‐Calculator Language USD:6‐9


          ssccaallee == 2200
          ddeeffiinnee ee((xx)){{
               aauuttoo aa,, bb,, cc,, dd,, nn
               aa == 11
               bb == 11
               cc == 11
               dd == 00
               nn == 11
               wwhhiillee((11====11)){{
                    aa == aa**xx
                    bb == bb**nn
                    cc == cc ++ aa//bb
                    nn == nn ++ 11
                    iiff((cc====dd)) rreettuurrnn((cc))
                    dd == cc
               }}
          }}


     SSoommee DDeettaaiillss

          There are some language features  that  every  user  should  know
     about even if he will not use them.

          Normally  statements are typed one to a line.  It is also permis‐
     sible to type several statements on a line separated by semicolons.

          If an assignment statement is parenthesized, it then has a  value
     and  it can be used anywhere that an expression can.  For example, the
     line

          ((xx==yy++1177))

     not only makes the indicated assignment, but also prints the resulting
     value.

          Here  is an example of a use of the value of an assignment state‐
     ment even when it is not parenthesized.

          xx == aa[[ii==ii++11]]

     causes a value to be assigned to x and also increments i before it  is
     used as a subscript.

          The following constructs work in BC in exactly the same manner as
     they do in the C language.  Consult the appendix or the C manuals  [2]
     for their exact workings.
















     USD:6‐10BC − An Arbitrary Precision Desk‐Calculator Language


          xx==yy==zz  iiss tthhee ssaammee aass  xx==((yy==zz))
          xx ++== yy              xx == xx++yy
          xx −−== yy              xx == xx−−yy
          xx **== yy              xx == xx**yy
          xx //== yy              xx == xx//yy
          xx %%== yy              xx == xx%%yy
          xx ^^== yy              xx == xx^^yy
          xx++++                 ((xx==xx++11))−−11
          xx−−−−                 ((xx==xx−−11))++11
          ++++xx                 xx == xx++11
          −−−−xx                 xx == xx−−11

     Even  if you don’t intend to use the constructs, if you type one inad‐
     vertently, something correct but unexpected may happen.

     TThhrreeee IImmppoorrttaanntt TThhiinnggss

          1.  To exit a BC program, type ‘quit’.

          2. There is a comment convention identical to that of  C  and  of
     PL/I.   Comments begin with ‘/*’ and end with ‘*/’.  As a non‐portable
     extension, comments may also start with a ‘#’ and end with a  newline.
     The newline is not part of the comment.

          3.  There is a library of math functions which may be obtained by
     typing at command level

          bbcc −−ll

     This command will load a set of library functions which, at  the  time
     of  writing,  consists  of  sine (named ‘s’), cosine (‘c’), arctangent
     (‘a’), natural logarithm (‘l’), exponential (‘e’) and Bessel functions
     of  integer  order (‘j(n,x)’).  Doubtless more functions will be added
     in time.  The library sets the scale to 20.  You can reset it to some‐
     thing else if you like.  The design of these mathematical library rou‐
     tines is discussed elsewhere [3].

          If you type

          bbcc ffiillee ......

     BC will read and execute the named file or files before accepting com‐
     mands from the keyboard.  In this way, you may load your favorite pro‐
     grams and function definitions.

     AAcckknnoowwlleeddggeemmeenntt

          The compiler is written in YACC [4]; its  original  version   was
     written by S. C. Johnson.

     RReeffeerreenncceess

     [1]  K.  Thompson  and  D.  M. Ritchie, _U_N_I_X _P_r_o_g_r_a_m_m_e_r_’_s _M_a_n_u_a_l_, Bell
          Laboratories, 1978.









     BC − An Arbitrary Precision Desk‐Calculator LanguageUSD:6‐11


     [2]  B. W. Kernighan and D. M. Ritchie, _T_h_e  _C  _P_r_o_g_r_a_m_m_i_n_g  _L_a_n_g_u_a_g_e_,
          Prentice‐Hall, 1978.

     [3]  R.  Morris,  _A _L_i_b_r_a_r_y _o_f _R_e_f_e_r_e_n_c_e _S_t_a_n_d_a_r_d _M_a_t_h_e_m_a_t_i_c_a_l _S_u_b_r_o_u_‐
          _t_i_n_e_s_, Bell Laboratories internal memorandum, 1975.

     [4]  S. C. Johnson, _Y_A_C_C _— _Y_e_t _A_n_o_t_h_e_r _C_o_m_p_i_l_e_r_‐_C_o_m_p_i_l_e_r_.  Bell  Labo‐
          ratories Computing Science Technical Report #32, 1978.

     [5]  R. Morris and L. L. Cherry, _D_C _− _A_n _I_n_t_e_r_a_c_t_i_v_e _D_e_s_k _C_a_l_c_u_l_a_t_o_r_.





















































     USD:6‐12BC − An Arbitrary Precision Desk‐Calculator Language


                                    Appendix


     11..  NNoottaattiioonn

          In  the following pages syntactic categories are in _i_t_a_l_i_c_s; lit‐
     erals are in bboolldd; material in brackets [] is optional.

     22..  TTookkeennss

          Tokens consist of keywords,  identifiers,  constants,  operators,
     and  separators.   Token  separators  may be blanks, tabs or comments.
     Newline characters or semicolons separate statements.

     22..11..  CCoommmmeennttss

          Comments are introduced by the characters /*  and  terminated  by
     */.  As a non‐portable extension, comments may also start with a # and
     end with a newline.  The newline is not part of the comment.

     22..22..  IIddeennttiiffiieerrss

          There are three kinds of identifiers − ordinary identifiers,  ar‐
     ray  identifiers and function identifiers.  All three types consist of
     single lower‐case letters.  Array identifiers are followed  by  square
     brackets,  possibly  enclosing  an  expression describing a subscript.
     Arrays are singly dimensioned and may contain  up  to  2048  elements.
     Indexing  begins  at  zero  so an array may be indexed from 0 to 2047.
     Subscripts are truncated to integers.  Function identifiers  are  fol‐
     lowed  by  parentheses, possibly enclosing arguments.  The three types
     of identifiers do not conflict; a program can have a variable named xx,
     an array named xx and a function named xx, all of which are separate and
     distinct.

     22..33..  KKeeyywwoorrddss

          The following are reserved keywords:
          iibbaasseeiiff
          oobbaasseebbrreeaakk
          ssccaalleeddeeffiinnee
          ssqqrrtt aauuttoo
          lleennggtthhrreettuurrnn
          wwhhiilleeqquuiitt
          ffoorr  ccoonnttiinnuuee
          eellssee llaasstt
          pprriinntt

     22..44..  CCoonnssttaannttss

          Constants consist of arbitrarily long numbers  with  an  optional
     decimal point.  The hexadecimal digits AA−FF are also recognized as dig‐
     its with values 10−15, respectively.











     BC − An Arbitrary Precision Desk‐Calculator LanguageUSD:6‐13


     33..  EExxpprreessssiioonnss

          The value of an expression is printed unless the main operator is
     an  assignment.  The value printed is assigned to the special variable
     llaasstt.  A single dot may be used as a synonym for llaasstt.  This is a non‐
     portable  extension.  Precedence is the same as the order of presenta‐
     tion here, with highest appearing first.  Left or right associativity,
     where applicable, is discussed with each operator.























































     USD:6‐14BC − An Arbitrary Precision Desk‐Calculator Language


     33..11..  PPrriimmiittiivvee eexxpprreessssiioonnss

     33..11..11..  NNaammeedd eexxpprreessssiioonnss

          Named  expressions  are  places  where values are stored.  Simply
     stated, named expressions are legal on the left side of an assignment.
     The  value  of  a  named  expression  is the value stored in the place
     named.

     33..11..11..11..  _i_d_e_n_t_i_f_i_e_r_s

          Simple identifiers are named expressions.  They have  an  initial
     value of zero.

     33..11..11..22..  _a_r_r_a_y_‐_n_a_m_e[[_e_x_p_r_e_s_s_i_o_n]]

          Array elements are named expressions.  They have an initial value
     of zero.

     33..11..11..33..  ssccaallee, iibbaassee and oobbaassee

          The internal registers ssccaallee, iibbaassee and oobbaassee are all  named  ex‐
     pressions.   ssccaallee  is the number of digits after the decimal point to
     be retained in arithmetic operations.  ssccaallee has an initial  value  of
     zero.   iibbaassee  and oobbaassee are the input and output number radix respec‐
     tively.  Both iibbaassee and oobbaassee have initial values of 10.

     33..11..22..  FFuunnccttiioonn ccaallllss

     33..11..22..11..  _f_u_n_c_t_i_o_n_‐_n_a_m_e(([_e_x_p_r_e_s_s_i_o_n[,,_e_x_p_r_e_s_s_i_o_n...]]))

          A function call consists of a function name followed by parenthe‐
     ses  containing  a  comma‐separated list of expressions, which are the
     function arguments.  A whole array passed as an argument is  specified
     by the array name followed by empty square brackets.  All function ar‐
     guments are passed by value.  As a result, changes made to the  formal
     parameters  have  no  effect on the actual arguments.  If the function
     terminates by executing a return statement, the value of the  function
     is the value of the expression in the parentheses of the return state‐
     ment or is zero if no expression is provided or if there is no  return
     statement.

     33..11..22..22..  ssqqrrtt((_e_x_p_r_e_s_s_i_o_n))

          The  result  is the square root of the expression.  The result is
     truncated in the least significant decimal place.  The  scale  of  the
     result is the scale of the expression or the value of ssccaallee,, whichever
     is larger.

     33..11..22..33..  lleennggtthh((_e_x_p_r_e_s_s_i_o_n))

          The result is the total number of significant decimal  digits  in
     the expression.  The scale of the result is zero.










     BC − An Arbitrary Precision Desk‐Calculator LanguageUSD:6‐15


     33..11..22..44..  ssccaallee((_e_x_p_r_e_s_s_i_o_n))

          The  result is the scale of the expression.  The scale of the re‐
     sult is zero.

     33..11..33..  CCoonnssttaannttss

          Constants are primitive expressions.

     33..11..44..  PPaarreenntthheesseess

          An expression surrounded by parentheses is  a  primitive  expres‐
     sion.  The parentheses are used to alter the normal precedence.

     33..22..  UUnnaarryy ooppeerraattoorrss

          The unary operators bind right to left.

     33..22..11..  −−_e_x_p_r_e_s_s_i_o_n

          The result is the negative of the expression.

     33..22..22..  ++++_n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n

          The  named  expression  is incremented by one.  The result is the
     value of the named expression after incrementing.

     33..22..33..  −−−−_n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n

          The named expression is decremented by one.  The  result  is  the
     value of the named expression after decrementing.

     33..22..44..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n++++

          The  named  expression  is incremented by one.  The result is the
     value of the named expression before incrementing.

     33..22..55..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n−−−−

          The named expression is decremented by one.  The  result  is  the
     value of the named expression before decrementing.

     33..33..  EExxppoonneennttiiaattiioonn ooppeerraattoorr

          The exponentiation operator binds right to left.

     33..33..11..  _e_x_p_r_e_s_s_i_o_n ^^ _e_x_p_r_e_s_s_i_o_n

          The  result  is  the  first expression raised to the power of the
     second expression.  The second expression must be an integer.  If _a is
     the  scale  of  the left expression and _b is the absolute value of the
     right expression, then the scale of the result is:











     USD:6‐16BC − An Arbitrary Precision Desk‐Calculator Language


          min(_a_×_b,max(ssccaallee,_a))

     33..44..  MMuullttiipplliiccaattiivvee ooppeerraattoorrss

          The operators *, /, % bind left to right.

     33..44..11..  _e_x_p_r_e_s_s_i_o_n ** _e_x_p_r_e_s_s_i_o_n

          The result is the product of the two expressions.  If _a and _b are
     the scales of the two expressions, then the scale of the result is:

          min(_a_+_b,max(ssccaallee,_a,_b))

     33..44..22..  _e_x_p_r_e_s_s_i_o_n // _e_x_p_r_e_s_s_i_o_n

          The  result is the quotient of the two expressions.  The scale of
     the result is the value of ssccaallee.

     33..44..33..  _e_x_p_r_e_s_s_i_o_n %% _e_x_p_r_e_s_s_i_o_n

          The % operator produces the remainder of the division of the  two
     expressions.  More precisely, _a%_b is _a−_a/_b*_b.

          The  scale  of  the result is the sum of the scale of the divisor
     and the value of ssccaallee

     33..55..  AAddddiittiivvee ooppeerraattoorrss

          The additive operators bind left to right.

     33..55..11..  _e_x_p_r_e_s_s_i_o_n ++ _e_x_p_r_e_s_s_i_o_n

          The result is the sum of the two expressions.  The scale  of  the
     result is the maximum of the scales of the expressions.

     33..55..22..  _e_x_p_r_e_s_s_i_o_n −− _e_x_p_r_e_s_s_i_o_n

          The  result  is the difference of the two expressions.  The scale
     of the result is the maximum of the scales of the expressions.

     33..66..  aassssiiggnnmmeenntt ooppeerraattoorrss

          The assignment operators bind right to left.

     33..66..11..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n == _e_x_p_r_e_s_s_i_o_n

          This expression results in assigning the value of the  expression
     on the right to the named expression on the left.

     33..66..22..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n ++== _e_x_p_r_e_s_s_i_o_n













     BC − An Arbitrary Precision Desk‐Calculator LanguageUSD:6‐17


     33..66..33..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n −−== _e_x_p_r_e_s_s_i_o_n

     33..66..44..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n **== _e_x_p_r_e_s_s_i_o_n

     33..66..55..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n //== _e_x_p_r_e_s_s_i_o_n

     33..66..66..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n %%== _e_x_p_r_e_s_s_i_o_n

     33..66..77..  _n_a_m_e_d_‐_e_x_p_r_e_s_s_i_o_n ^^== _e_x_p_r_e_s_s_i_o_n

          The  result of the above expressions is equivalent to ‘‘named ex‐
     pression = named expression OP expression’’, where OP is the  operator
     after the = sign.

     44..  RReellaattiioonnss

          Unlike  all  other  operators,  the relational operators are only
     valid as the object of an iiff, wwhhiillee, or inside a ffoorr statement.

     44..11..  _e_x_p_r_e_s_s_i_o_n << _e_x_p_r_e_s_s_i_o_n

     44..22..  _e_x_p_r_e_s_s_i_o_n >> _e_x_p_r_e_s_s_i_o_n

     44..33..  _e_x_p_r_e_s_s_i_o_n <<== _e_x_p_r_e_s_s_i_o_n

     44..44..  _e_x_p_r_e_s_s_i_o_n >>== _e_x_p_r_e_s_s_i_o_n

     44..55..  _e_x_p_r_e_s_s_i_o_n ==== _e_x_p_r_e_s_s_i_o_n

     44..66..  _e_x_p_r_e_s_s_i_o_n !!== _e_x_p_r_e_s_s_i_o_n

     55..  SSttoorraaggee ccllaasssseess

          There are only two storage classes in BC,  global  and  automatic
     (local).   Only identifiers that are to be local to a function need be
     declared with the aauuttoo command.  The arguments to a function are local
     to  the  function.  All other identifiers are assumed to be global and
     available to all functions.  All identifiers, global and  local,  have
     initial values of zero.  Identifiers declared as aauuttoo are allocated on
     entry to the function and released on  returning  from  the  function.
     They  therefore do not retain values between function calls.  aauuttoo ar‐
     rays are specified by the array name followed by empty  square  brack‐
     ets.

          Automatic  variables in BC do not work in exactly the same way as
     in either C or PL/I.  On entry to a function, the old  values  of  the
     names  that appear as parameters and as automatic variables are pushed
     onto a stack.  Until return is made from the  function,  reference  to
     these names refers only to the new values.

     66..  SSttaatteemmeennttss

          Statements  must  be  separated  by semicolon or newline.  Except
     where altered by control statements, execution is sequential.









     USD:6‐18BC − An Arbitrary Precision Desk‐Calculator Language


     66..11..  EExxpprreessssiioonn ssttaatteemmeennttss

          When a statement is an expression, unless the main operator is an
     assignment, the value of the expression is printed, followed by a new‐
     line character.

     66..22..  CCoommppoouunndd ssttaatteemmeennttss

          Statements may be grouped together and used when one statement is
     expected by surrounding them with { }.

     66..33..  QQuuootteedd ssttrriinngg ssttaatteemmeennttss

          "any string"
     This statement prints the string inside the quotes.

     66..44..  IIff ssttaatteemmeennttss
     iiff((_r_e_l_a_t_i_o_n))_s_t_a_t_e_m_e_n_t

          The substatement is executed if the relation is true.

     66..55..  IIff‐‐eellssee ssttaatteemmeennttss
     iiff((_r_e_l_a_t_i_o_n))_s_t_a_t_e_m_e_n_teellssee_s_t_a_t_e_m_e_n_t

          The  first  substatement is executed if the relation is true, the
     second substatement if the relation is false.  The  iiff‐‐eellssee  statement
     is a non‐portable extension.

     66..66..  WWhhiillee ssttaatteemmeennttss
     wwhhiillee((_r_e_l_a_t_i_o_n))_s_t_a_t_e_m_e_n_t

          The  statement  is executed while the relation is true.  The test
     occurs before each execution of the statement.

     66..77..  FFoorr ssttaatteemmeennttss
     ffoorr((_e_x_p_r_e_s_s_i_o_n;; _r_e_l_a_t_i_o_n;; _e_x_p_r_e_s_s_i_o_n))_s_t_a_t_e_m_e_n_t

          The ffoorr statement is the same as
          _f_i_r_s_t_‐_e_x_p_r_e_s_s_i_o_n
          wwhhiillee((_r_e_l_a_t_i_o_n)) {{
               _s_t_a_t_e_m_e_n_t
               _l_a_s_t_‐_e_x_p_r_e_s_s_i_o_n
          _}

          All three expressions may be left out.  This  is  a  non‐portable
     extension.

     66..88..  BBrreeaakk ssttaatteemmeennttss
     bbrreeaakk

          bbrreeaakk causes termination of a ffoorr or wwhhiillee statement.












     BC − An Arbitrary Precision Desk‐Calculator LanguageUSD:6‐19


     66..99..  CCoonnttiinnuuee ssttaatteemmeennttss
     ccoonnttiinnuuee

          ccoonnttiinnuuee causes the next iteration of a ffoorr or wwhhiillee statement to
     start, skipping the remainder of the loop.  For a wwhhiillee statement, ex‐
     ecution  continues  with  the  evaluation of the condition.  For a ffoorr
     statement, execution continues with evaluation of the last‐expression.
     The ccoonnttiinnuuee statement is a non‐portable extension.

     66..1100..  AAuuttoo ssttaatteemmeennttss
     aauuttoo _i_d_e_n_t_i_f_i_e_r[,,_i_d_e_n_t_i_f_i_e_r]

          The  aauuttoo  statement  causes  the values of the identifiers to be
     pushed down.  The identifiers can be  ordinary  identifiers  or  array
     identifiers.   Array  identifiers are specified by following the array
     name by empty square brackets.  The auto statement must be  the  first
     statement in a function definition.

     66..1111..  DDeeffiinnee ssttaatteemmeennttss
     ddeeffiinnee(([_p_a_r_a_m_e_t_e_r[,,_p_a_r_a_m_e_t_e_r_._._.]])){{
          _s_t_a_t_e_m_e_n_t_s}}

          The  ddeeffiinnee  statement defines a function.  The parameters may be
     ordinary identifiers or array names.  Array names must be followed  by
     empty square brackets.  As a non‐portable extension, the opening brace
     may also appear on the next line.

     66..1122..  RReettuurrnn ssttaatteemmeennttss
     rreettuurrnn
     rreettuurrnn((_e_x_p_r_e_s_s_i_o_n))

          The rreettuurrnn statement causes termination of a function, popping of
     its  auto  variables,  and  specifies the result of the function.  The
     first form is equivalent to rreettuurrnn((00)).  The result of the function  is
     the  result of the expression in parentheses.  Leaving out the expres‐
     sion between parentheses is equivalent to rreettuurrnn((00)).  As a  non‐porta‐
     ble extension, the parentheses may be left out.

     66..1133..  PPrriinntt

          The  pprriinntt statement takes a list of comma‐separated expressions.
     Each expression in the list is evaluated and  the  computed  value  is
     printed  and  assigned to the variable ‘last’.  No trailing newline is
     printed.  The expression may also  be  a  string  enclosed  in  double
     quotes.   Within  these  strings the following escape sequences may be
     used: \a for bell (alert), ‘\b’ for backspace, ‘\f’ for formfeed, ‘\n’
     for  newline, ‘\r’ for carriage return, ‘\t’ ‘for tab, ‘\q’ for double
     quote and ‘\\’ for backslash.  Any other character following  a  back‐
     slash  will  be ignored.  Strings will not be assigned to ‘last’.  The
     pprriinntt statement is a non‐portable extension.













     USD:6‐20BC − An Arbitrary Precision Desk‐Calculator Language


     66..1144..  QQuuiitt

          The qquuiitt statement stops execution of a BC  program  and  returns
     control  to  UNIX  when  it  is  first encountered.  Because it is not
     treated as an executable statement, it cannot be used  in  a  function
     definition or in an iiff,, ffoorr,, or wwhhiillee statement.






















































